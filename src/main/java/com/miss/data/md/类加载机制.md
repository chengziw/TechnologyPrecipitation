[TOC]





## 关于类加载机制，你知道多少



### 什么是类加载

​		简单来说类加载就是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**中创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。

​		类的加载的最终结果就是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 

### 类加载的过程

#### 加载

 JVM 在该阶段的主要目的是将字节码从不同的数据源（见下）转化为二进制字节流加载到内存中， 然后将这个字节流所代表的的**静态存储结构转化为方法区的运行时数据结构**，并且在堆中生成 Class对象 ，作为其他调用的入口。 

**数据源：**

- 从本地文件系统加载class文件。
- 从JAR包中加载class文件，如数据库启驱动类。
- 通过网络加载class文件（序列化）。
- 将一个Java源文件动态编译并执行加载。

#### 验证

 JVM 会在该阶段对二进制字节流进行安全性校验，是保证加载数据正确性的重要保障。

**验证内容：**

- **文件格式**：确保二进制字节流格式符合预期（比如说是否以 `cafe bene` 开头）。
- **元数据验证**: 主要对字节码描述的信息进行语义分析 ，例如是否有父类，子父类是否符合约束。
- **字节码验证**：是真个验证阶段最关键的部分。主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事，例如子类的方法访问级别高于父类。 
- **符号引用验证**：确保变量是否正确初始化。

#### 准备

准备阶段主要为类变量分配内存并设置初始值。

-  类变量(static)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。 
-  初始值通常情况下是数据类型默认的零值（如0、0L、null、false等）。

#### 解析

 虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。

-  在class文件被加载至Java虚拟机前，这个类无法知道其它类及其方法、字段所对应的具体地址等。
- 这时Java编译器会生成一个符号引用。符号引用指向具体目标。解析阶段的目的，正是将这些符号引用解析为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（这个时候就又会触发加载过程就解释了下文的小贴士）。  

#### 初始化

 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。 

##### 设定初始值的方式

-  声明类变量是指定初始值 
- 使用静态代码块为类变量指定初始值

##### 初始化步骤

- 假如这个类还没有被加载和连接，则程序先加载并连接该类。
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类。
- 假如类中有初始化语句，则系统依次执行这些初始化语句。

##### 初始化的时机

- 创建类的实例，也就是new的方式。
- 访问某个类或接口的静态变量，或者对该静态变量赋值。
- 调用类的静态方法。
- 反射（如Class.forName(“com.shengsiyuan.Test”)）。
- 初始化某个类的子类，则其父类也会被初始化。
- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类。

**小贴士：** 注意这里的几个阶段是按顺序**开始**，但不一定是按顺序**进行**或**完成**的，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 



## java初始化顺序

- 父类的静态变量。
- 父类的静态代码块。
- 子类的静态变量。
- 子类的静态代码块。
- 父类的非静态变量。
- 父类的非静态代码块。
- 父类的构造方法。
- 子类的非静态变量。
- 子类的非静态代码块。
- 子类的构造方法

## 类加载器

###  Bootstrap ClassLoader 

 **根类（或叫启动、引导类加载器）加载器** 

- 负责加载存放在jdk安装路径\jre\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar。所有的java.*开头的类均被Bootstrap ClassLoader加载）。 
- 底层由原生C++代码实现的，并不是java.lang.ClassLoader的子类。

##  Extension ClassLoader

**扩展类加载器**

-  它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类） 。
- 我们可以通过把自己开发的类打包成JAR文件放入扩展目录来为Java扩展核心类以外的新功能。 

###  Application ClassLoader 

**系统加载器**

-  它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。
- 程序可以通过ClassLoader的静态方法getSystemClassLoader来获取系统类加载器 

## Customer ClassLoader

**用户自定义加载器**

 JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，自定义加载器就可以灵活的加载，例如spring加载配置文件等。

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java.class，例如序列化对象。

### 加载器的层级关系

 **这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。**

### ![1589276726507](C:\Users\王延\AppData\Roaming\Typora\typora-user-images\1589276726507.png)



## java的类加载机制

- **全盘负责**：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **父类委托**：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类（加载顺序自顶向下，检查顺序自底向上）。
- **缓存机制**：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。

## 类加载方式

- 命令行启动应用时候由JVM初始化加载。
- 通过Class.forName()方法动态加载。
- 通过ClassLoader.loadClass()方法动态加载。

## 双亲委托

### 流程

-  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成。
- 依次向上请求父类去加载，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。
- 只有当父加载器在它的搜索范围中没有找到所需的类时，子加载器才会尝试自己去加载该类。 

### 详解

**使用代理模式，子类让父类代理去加载。**

- 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
- 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
- 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载。
- 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

### 意义

- 系统类防止内存中出现多份同样的字节码。
- 保证Java程序安全稳定运行。
- 防止对象注入，保证级别更高的对象拥有更高优先级，不会被自定文件覆盖。

## 线程上下文类加载器

从jdk1.2开始支持线程上下文类加载器

 **通常当你需要动态加载资源的时候 , 你至少有三个 ClassLoader 可以选择** 

- 系统类加载器或叫作应用类加载器 (system classloader or application classloader)。
- 当前类加载器。
- 当前线程类加载器。 

**当前线程类加载器是为了抛弃双亲委派加载链模式。**
 每个线程都有一个关联的上下文类加载器。当我们需要定义覆盖系统默认的类时，可以使用这种方式，不过并不建议，出于安全考虑。

 **• Thread.currentThread().getContextClassLoader()**

## Tomcat服务器的类加载器。

每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式(不同于前面说的双亲委托机制)，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。但也是为了保证安全，这样核心库就不在查询范围之内。

------

参考：

《深入理解Java虚拟机》

《深入理解JVM》

《Java程序员修炼之道》

**深入探讨类加载机制**[地址]( https://www.ibm.com/developerworks/cn/java/j-lo-classloader/)

**类加载过程**[地址](https://www.jianshu.com/p/dd39654231e0)